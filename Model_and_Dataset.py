# -*- coding: utf-8 -*-
"""Model_and_Dataset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ph-1Mz11biT0dIBtpC36Rr0fRPDXMg4Z
"""

from IPython.display import clear_output
from collections import defaultdict
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import torch
import torchvision
import os
from torch.utils.data import Dataset
from torchvision import datasets
from torch.utils.data import TensorDataset

class CustomStructureDataset(Dataset):
    def __init__(self, annotations_file, train = True, normalize = None, mean = None, std = None, transform = None,  str_dir = 'drive/MyDrive/Dataset'):
        self.str_labels = pd.read_csv(annotations_file, header=None)
        self.str_dir = str_dir
        self.train = train
        self.normalize = normalize
        self.mean = mean
        self.std = std
        self.transform = transform

    def __len__(self):
        return len(self.str_labels)

    def __getitem__(self, idx):
        str_path = os.path.join(self.str_dir, self.str_labels.iloc[idx, 1])
        structure = np.load(str_path)
        rand_num = np.random.rand(4)
        if self.transform:
          
          if rand_num[0] < 0.5:
            structure = np.flip(structure, axis = 1)
          if rand_num[1] < 0.5:
            structure = np.flip(structure, axis = 2)
          if rand_num[2] < 0.5:
            structure = np.flip(structure, axis = 3)
        label = float(self.str_labels.iloc[idx, 2])
        if self.normalize:
            label = (label-self.mean)/self.std
        if self.train == True and  rand_num[3] < 0.5:
            structure = np.where(structure == 0, structure, structure*-1)
        structure = torch.from_numpy(structure.copy())
        if self.transform_str:
          structure = self.transform_str(structure, self.mean_str, self.std_str)
        return structure, label

import torch.nn as nn
import torch
from torch.nn.modules.container import Sequential

class First_CNN(nn.Module):

    def __init__(self):
        super().__init__()      
        self.conv_stack = nn.Sequential(
            nn.Conv3d(10, 32, 7, padding=3, bias=False), # in channel=10, out=32
            nn.MaxPool3d(2), # size [32, length/2, width/2, high/2]
            nn.ReLU(),
            nn.BatchNorm3d(32),
            nn.Conv3d(32, 64, 5, padding=2, bias=False), # in channel=32, out=64 
            nn.MaxPool3d(2), # size [64,length/2/2,width/2/2, high/2/2]
            nn.ReLU(),
            nn.BatchNorm3d(64),
            
            nn.Conv3d(64, 128, 3, padding=1, bias=False), # in channel=64, out=128 
            nn.MaxPool3d(2), # size [128,length//2//2, width//2//2, high//2//2]
            nn.ReLU(),
            nn.BatchNorm3d(128),
            nn.Flatten(),
            nn.Linear(128*(61//2//2//2)*(61//2//2//2)*(21//2//2//2), 1000),
            nn.Dropout(0.3), 
            nn.ReLU(),
            nn.Linear(1000, 200),
            nn.Dropout(0.3),
            nn.ReLU(),
            nn.Linear(200, 1))

    def forward(self, x):
      x = self.conv_stack(x) 
      return x